(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{421:function(t,a,s){"use strict";s.r(a);var r=s(56),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"유클리드-호제법"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#유클리드-호제법"}},[t._v("#")]),t._v(" 유클리드 호제법")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("- BJ/9613 Sum of GCD\n- BJ/17087 숨바꼭질 6\n")])])]),s("p",[t._v("정수 a와 b의 최대공약수를 구하려면 어떻게 해야할까. 코드포스에서 "),s("code",[t._v("coprime")]),t._v(" 관련 문제 풀다가 찾아봤다. (참고로 쓰면서 깨달았는데 coprime은 "),s("code",[t._v("서로소")]),t._v("이다.)")]),t._v(" "),s("p",[t._v("영문으로는 "),s("code",[t._v("Euclidean Algorithm")]),t._v("으로 알려진 유클리드 호제법에서 막(?) 좋은 그거는 '호재'고 "),s("code",[t._v("서로 나눈다는")]),t._v(" 뜻에서 '호제'법이라고 한다.")]),t._v(" "),s("p",[t._v("기가막히게도 1071, 1029의 최대공약수를 구하려면 연산 두세번만에 21이라는 것을 구할 수 있다.")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("(1071, 1029) = (1029, 42)\n             = (42, 21)\n             = (21, 0)\n             = 21\n")])])]),s("h2",{attrs:{id:"implementation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[t._v("#")]),t._v(" Implementation.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("euclidean_gcd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    r "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"lemma"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lemma"}},[t._v("#")]),t._v(" Lemma.")]),t._v(" "),s("blockquote",[s("p",[t._v("a = bq + r 이면, gcd(a, b) = gcd(b, r) 이다.")])]),t._v(" "),s("h2",{attrs:{id:"proof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proof"}},[t._v("#")]),t._v(" Proof.")]),t._v(" "),s("p",[t._v("a, b가 0보다 큰 정수이고 a는 b보다 같거나 클 때, "),s("code",[t._v("a = bq + r")]),t._v(" 을 만족하는 유일한 정수 b, r이 존재한다. 여기서 b는 1 이상이고, r는 0 이상 b 미만일 것이다.")]),t._v(" "),s("p",[t._v("최대공약수 (a, b) = d 일 때,")]),t._v(" "),s("p",[t._v("a = dα, b = dβ 라고 하자.")]),t._v(" "),s("p",[t._v("이 때 α, β은 coprime이다.")]),t._v(" "),s("p",[s("code",[t._v("a = bq + r")]),t._v(" 에서\ndα = dβq + r\ndα - dβq = r")]),t._v(" "),s("p",[t._v("∴ r = d(α - βq), b = dβ 이다.")]),t._v(" "),s("p",[t._v("이 때 r과 b는 공약수 d를 갖는데, (α - βq)와 β가 coprime이면 (a, b) = (b, r)이 성립한다.")]),t._v(" "),s("p",[t._v("만약 α - βq = mt, β = nt가 1 보다 큰 정수 t를 최대공약수로 갖는다고 가정하자.")]),t._v(" "),s("p",[t._v("α - βq = α - (nt)q  = mt")]),t._v(" "),s("p",[t._v("∴ α = mt + ntq = t(m + nq), b = tn 이므로 앞의 가정과 모순되므로 Proof by contradiction (귀류법에 의해서 증명).")]),t._v(" "),s("h2",{attrs:{id:"ref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" Ref.")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("David Burton. (2010). Elementary Number Theory; 7th editon (pp. 26-27). n.p.: McGraw Hill.")])]),t._v(" "),s("li",[s("p",[t._v("https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95")])]),t._v(" "),s("li",[s("p",[t._v("https://sseong40.tistory.com/3")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);